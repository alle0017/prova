{"files":{"pxt.json":"{\n    \"name\": \"pxt-status-bar\",\n    \"version\": \"0.4.1\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"status-bar.ts\",\n        \"docs/value.md\",\n        \"docs/max.md\",\n        \"docs/attach-to-sprite.md\",\n        \"docs/sprite-attached-to.md\",\n        \"docs/set-color.md\",\n        \"docs/set-bar-border.md\",\n        \"docs/set-label.md\",\n        \"docs/set-status-bar-flag.md\",\n        \"docs/set-bar-size.md\",\n        \"docs/position-direction.md\",\n        \"docs/set-offset-padding.md\",\n        \"docs/create.md\",\n        \"docs/get-status-bar-attached-to.md\",\n        \"docs/on-zero.md\",\n        \"docs/on-status-reached.md\",\n        \"docs/on-display-updated.md\",\n        \"docs/all-of-kind.md\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"1.3.44\",\n        \"targetId\": \"arcade\"\n    },\n    \"supportedTargets\": [\n        \"arcade\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n","README.md":"---\ntitle: PXT Status Bar\ndescription: General purpose status bars --beta\n---\n\n> Open this page at [https://jwunderl.github.io/pxt-status-bar/](https://jwunderl.github.io/pxt-status-bar/)\n\n## Use this extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://arcade.makecode.com/](https://arcade.makecode.com/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/jwunderl/pxt-status-bar** and import\n\n## Block Docs\n\n### statusbars.create\n\nThis creates a status bar\n\n```blocks\nlet statusbar = statusbars.create(20, 4, StatusBarKind.Health)\n```\n\n\n## Edit this extension ![Build status badge](https://github.com/jwunderl/pxt-status-bar/workflows/MakeCode/badge.svg)\n\nTo edit this repository in MakeCode.\n\n* open [https://arcade.makecode.com/](https://arcade.makecode.com/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/jwunderl/pxt-status-bar** and click import\n\n## Blocks preview\n\nThis image shows the blocks code from the last commit in master.\nThis image may take a few minutes to refresh.\n\n![A rendered view of the blocks](https://github.com/jwunderl/pxt-status-bar/raw/master/.github/makecode/blocks.png)\n\n#### Metadata (used for search, rendering)\n\n* for PXT/arcade\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n","status-bar.ts":"enum StatusBarFlag {\n    //% blockHidden=true\n    None = 0,\n    // if set, update bar over time; otherwise update bar immediately\n    //% block=\"smooth transition\"\n    //% block.loc.ru=\"плавное изменение\"\n    SmoothTransition = 1 << 0,\n    // if set, and label exists, draw label at bottom or right side\n    //% block=\"label at end\"\n    //% block.loc.ru=\"подпись в конце\"\n    LabelAtEnd = 1 << 1,\n    // if set, constrain values stored in status bar between 0 and max\n    //% block=\"constrain value\"\n    //% block.loc.ru=\"максимальное значение\"\n    ConstrainAssignedValue = 1 << 2,\n    // if set, start 'on' from opposite side (top or right)\n    //% block=\"invert fill direction\"\n    //% block.loc.ru=\"заполнять в обратную сторону\"\n    InvertFillDirection = 1 << 3,\n    // if set, do not immediately show target when transitioning\n    //% block=\"hide transition preview\"\n    //% block.loc.ru=\"скрыть предпросмотр изменения\"\n    HideTargetPreview = 1 << 4,\n    // if set, do not destroy this status bar when sprite it is attached to is destroyed\n    //% block=\"no autodestroy on attached destroy\"\n    //% block.loc.ru=\"не уничтожать вместе с присоединенным спрайтом\"\n    NoAutoDestroy = 1 << 5,\n    // if set, do not run `on zero` or `on status changed` events when changing values on this status bar.\n    //% block=\"ignore events\"\n    //% block.loc.ru=\"игнорировать события\"\n    IgnoreValueEvents = 1 << 6,\n}\n\nnamespace SpriteKind {\n    //% isKind\n    export const StatusBar = SpriteKind.create();\n}\n\nnamespace StatusBarKind {\n    /**\n     * Gets the \"kind\" of a status bar\n     */\n    //% shim=KIND_GET\n    //% blockId=\"statusbars_kind\" block=\"$kind\"\n    //% kindNamespace=StatusBarKind kindMemberName=kind kindPromptHint=\"e.g. Hungry, Thirst, ...\"\n    //% blockHidden=true\n    export function _statusbarKind(kind: number): number {\n        return kind;\n    }\n\n    let nextKind: number\n    export function create() {\n        if (nextKind === undefined) nextKind = 1;\n        return nextKind++;\n    }\n\n    //% isKind\n    export const Health = create();\n\n    //% isKind\n    export const Energy = create();\n\n    //% isKind\n    export const Magic = create();\n\n    //% isKind\n    export const EnemyHealth = create();\n}\n\n// TODO: allow timing fn for transition between prev and curr value, instead of just 100ms\n\n// TODO: angled bars?  /::::::::::/ instead of |::::::::::|\n\n// TODO: 'rounded border' / border-radius option? just 1px or 2px\n\n//% blockNamespace=\"statusbars\"\n//% blockGap=8\nclass StatusBarSprite extends Sprite {\n    constructor(public _statusBar: statusbars.StatusBar) {\n        super(_statusBar.image);\n    }\n\n    //% group=\"Value\" blockSetVariable=\"statusbar\"\n    //% blockCombine block=\"value\" callInDebugger\n    //% help=github:pxt-status-bar/docs/value\n    get value(): number {\n        return this.applyChange(sb => sb.current) || 0;\n    }\n\n    set value(v: number) {\n        this.applyChange(sb => {\n            sb.current = v;\n        });\n    }\n\n    //% group=\"Value\" blockSetVariable=\"statusbar\"\n    //% blockCombine block=\"max\" callInDebugger\n    //% help=github:pxt-status-bar/docs/max\n    get max(): number {\n        return this.applyChange(sb => sb.max) || 0;\n    }\n\n    set max(v: number) {\n        this.applyChange(sb => {\n            sb.max = v;\n        });\n    }\n\n    //% block=\"attach $this(statusbar) to $toFollow=variables_get(mySprite)||padding $padding offset $offset\"\n    //% block.loc.ru=\"прикрепить $this(statusbar) к $toFollow=variables_get(mySprite)||отступ $padding смещение $offset\"\n    //% blockId=\"statusbars_attachToSprite\"\n    //% expandableArgumentMode=\"toggle\"\n    //% inlineInputMode=\"inline\"\n    //% help=github:pxt-status-bar/docs/attach-to-sprite\n    //% group=\"Attach\"\n    //% weight=85\n    attachToSprite(toFollow: Sprite, padding?: number, offset?: number) {\n        this.applyChange(sb => {\n            // reset this to the default value;\n            // this will be changed with the follow logic to match toFollow,\n            // but if this is being reassigned it should handle that gracefully\n            this.setFlag(SpriteFlag.RelativeToCamera, true);\n            sb.spriteToFollow = toFollow;\n            if (sb.followPadding === undefined || padding !== undefined) {\n                sb.followPadding = padding || 0;\n            }\n            if (sb.followOffset === undefined || padding !== undefined) {\n                sb.followOffset = offset || 0;\n            }\n            if (toFollow)\n                sb.positionNextTo(this, toFollow);\n        });\n    }\n\n    //% block=\"sprite that $this(statusbar) is attached to\"\n    //% block.loc.ru=\"спрайт к которому прикреплен $this(statusbar)\"\n    //% blockId=\"statusbars_attachSpriteGetter\"\n    //% help=github:pxt-status-bar/docs/sprite-attached-to\n    //% group=\"Attach\"\n    //% weight=83\n    spriteAttachedTo() {\n        return this.applyChange(sb => sb.spriteToFollow);\n    }\n\n    /**\n     * @param status status bar to apply change to\n     * @param fillColor color to fill bar with, eg: 0x7\n     * @param bkgdColor bar background color, eg: 0x2\n     * @param drainColor color to show while value is being changed; eg: 0x3\n     */\n    //% block=\"set $this(statusbar) fill $fillColor background $bkgdColor||drain color $drainColor\"\n    //% block.loc.ru=\"установить для $this(statusbar) цвет $fillColor фон $bkgdColor||цвет уменьшения $drainColor\"\n    //% blockId=\"statusbars_setColor\"\n    //% fillColor.shadow=\"colorindexpicker\"\n    //% bkgdColor.shadow=\"colorindexpicker\"\n    //% drainColor.shadow=\"colorindexpicker\"\n    //% help=github:pxt-status-bar/docs/set-color\n    //% group=\"Display\"\n    //% weight=75\n    setColor(fillColor: number, bkgdColor: number, drainColor?: number) {\n        this.applyChange(sb => {\n            sb.onColor = fillColor;\n            sb.offColor = bkgdColor;\n\n            if (drainColor != null) {\n                sb.drainColor = drainColor;\n            }\n        });\n    }\n\n    /**\n     * @param status status bar to add border to\n     * @param borderWidth width of border in pixels, eg: 1\n     * @param color color of border, eg: 0xd\n     */\n    //% block=\"set $this(statusbar) border width $borderWidth $color\"\n    //% block.loc.ru=\"установить для $this(statusbar) рамку толщиной $borderWidth цветом $color\"\n    //% blockId=\"statusbars_setBorder\"\n    //% color.shadow=\"colorindexpicker\"\n    //% help=github:pxt-status-bar/docs/set-bar-border\n    //% group=\"Display\"\n    //% weight=74\n    setBarBorder(borderWidth: number, color: number) {\n        this.applyChange(sb => {\n            sb.borderColor = color;\n            sb.borderWidth = borderWidth;\n        });\n    }\n\n    /**\n     * @param status status bar to add label to\n     * @param label label to add to status bar, eg: HP\n     * @param color color of label, eg: 0x1\n     */\n    //% block=\"set $this(statusbar) label $label||$color\"\n    //% block.loc.ru=\"установить для $this(statusbar) подпись $label||$color\"\n    //% blockId=\"statusbar_setLabel\"\n    //% color.shadow=\"colorindexpicker\"\n    //% help=github:pxt-status-bar/docs/set-label\n    //% group=\"Display\"\n    //% weight=73\n    setLabel(label: string, color?: number) {\n        this.applyChange(sb => {\n            if (color)\n                sb.labelColor = color;\n            sb.label = label;\n        });\n    }\n\n    //% block=\"set $this(statusbar) $flag $on=toggleOnOff\"\n    //% block.loc.ru=\"установить для $this(statusbar) $flag $on=toggleOnOff\"\n    //% blockId=\"statusbars_setFlag\"\n    //% help=github:pxt-status-bar/docs/set-status-bar-flag\n    //% group=\"Display\"\n    //% weight=72\n    setStatusBarFlag(flag: StatusBarFlag, on: boolean) {\n        this.applyChange(sb => {\n            sb.setFlag(flag, on);\n        });\n    }\n\n    /**\n     * @param width width of status bar, eg: 20\n     * @param height height of status bar, eg: 4\n     */\n    //% block=\"set $this(statusbar) width $width height $height\"\n    //% block.loc.ru=\"установить для $this(statusbar) ширину $width высоту $height\"\n    //% blockId=\"statusbars_setBarSize\"\n    //% help=github:pxt-status-bar/docs/set-bar-size\n    //% group=Display\n    //% weight=71\n    setBarSize(width: number, height: number) {\n        this.applyChange(sb => {\n            sb.barWidth = width;\n            sb.barHeight = height;\n        });\n    }\n\n    //% block=\"set $this(statusbar) position to $dir\"\n    //% block.loc.ru=\"установить позицию $this(statusbar) $dir\"\n    //% blockId=\"statusbars_positionNextToSprite\"\n    //% help=github:pxt-status-bar/docs/position-direction\n    //% group=\"Display\"\n    //% weight=70\n    positionDirection(dir: CollisionDirection) {\n        this.applyChange(sb => {\n            sb.explicitlySetDirection = dir;\n            if (sb.spriteToFollow) {\n                sb.positionNextTo(this, sb.spriteToFollow);\n            } else {\n                // if no position, set to side of the screen\n                if (dir === CollisionDirection.Top || dir === CollisionDirection.Bottom) {\n                    this.x = (screen.width >> 1) + sb.followOffset;\n                    if (dir === CollisionDirection.Top) {\n                        this.top = sb.followPadding;\n                    } else {\n                        this.bottom = screen.height - sb.followPadding;\n                    }\n                } else {\n                    this.y = (screen.height >> 1) + sb.followOffset;\n                    if (dir === CollisionDirection.Left) {\n                        this.left = sb.followPadding;\n                    } else {\n                        this.right = screen.width - sb.followPadding;\n                    }\n                }\n            }\n        });\n    }\n\n    //% block=\"set $this(statusbar) padding $padding offset $offset\"\n    //% block.loc.ru=\"установить для $this(statusbar) отступ $padding смещение $offset\"\n    //% blockId=\"setPaddingOffset\"\n    //% help=github:pxt-status-bar/docs/set-offset-padding\n    //% group=\"Display\"\n    //% weight=69\n    setOffsetPadding(offset: number, padding: number) {\n        this.applyChange(sb => {\n            if (!sb.spriteToFollow && sb.explicitlySetDirection !== null) {\n                switch (sb.explicitlySetDirection) {\n                    case CollisionDirection.Top:\n                        this.x += offset - sb.followOffset;\n                        this.y += padding + sb.followPadding;\n                        break;\n                    case CollisionDirection.Bottom:\n                        this.x += offset - sb.followOffset;\n                        this.y -= padding + sb.followPadding;\n                        break;\n                    case CollisionDirection.Left:\n                        this.x += padding + sb.followPadding;\n                        this.y += offset - sb.followOffset;\n                        break\n                    case CollisionDirection.Right:\n                        this.x -= padding + sb.followPadding;\n                        this.y += offset - sb.followOffset;\n                        break\n                }\n            }\n            sb.followOffset = offset;\n            sb.followPadding = padding;\n            if (sb.spriteToFollow) {\n                sb.positionNextTo(this, sb.spriteToFollow);\n            }\n        })\n    }\n\n    freeze() {\n        this.applyChange(sb => sb.freeze());\n    }\n    \n    private applyChange<T>(action: (sb: statusbars.StatusBar) => T): T {\n        const sb = this._statusBar;\n\n        if (sb) {\n            const output = action(sb);\n            sb.updateDisplay();\n            this.setImage(sb.image);\n            return output;\n        }\n\n        return undefined;\n    }\n}\n\n//% color=#38364d\n//% weight=79\n//% icon=\"\\uf240\"\n//% blockGap=8 block=\"Status Bars\"\n//% groups='[\"Create\", \"Value\", \"Attach\", \"Display\", \"Events\", \"Other\"]'\nnamespace statusbars {\n    const STATUS_BAR_DATA_KEY = \"STATUS_BAR_DATA_KEY\";\n    const MANAGED_SPRITES_KEY = STATUS_BAR_DATA_KEY + \"_SPRITES\";\n    const ZERO_HANDLERS_KEY = STATUS_BAR_DATA_KEY + \"_ON_ZERO\";\n    const STATUS_HANDLERS_KEY = STATUS_BAR_DATA_KEY + \"_ON_STATUS_REACHED\";\n    const POST_PROCESS_HANDLERS_KEY = STATUS_BAR_DATA_KEY + \"_ON_DISPLAY_UPDATE\";\n\n    export class StatusBar {\n        // the sprite this is attached to\n        sprite: Sprite;\n        borderWidth: number;\n        // if not set, use offColor\n        borderColor: number;\n        labelColor: number;\n\n        flags: number;\n        protected _label: string;\n        protected _image: Image;\n\n        spriteToFollow: Sprite;\n        // how far away from touching the sprite to be\n        followPadding: number;\n        // offset beside sprite; -5 will offset bar 5 to the left or above (depending on horizontal / vertical bar)\n        followOffset: number;\n        explicitlySetDirection: CollisionDirection;\n\n        protected font: image.Font;\n\n        // hold state\n        protected displayValue: number;\n        protected target: number;\n\n        hasHitZero: boolean;\n\n        constructor(\n            protected _barWidth: number,\n            protected _barHeight: number,\n            public onColor: number,\n            public offColor: number,\n            public drainColor: number,\n            protected _max: number,\n            public kind: number\n        ) {\n            this.borderWidth = 0;\n            this.borderColor = undefined;\n            this.flags = StatusBarFlag.ConstrainAssignedValue;\n            this._label = undefined;\n            this.labelColor = 0x1;\n            this.font = image.font5;\n\n            this.followPadding = 0;\n            this.followOffset = 0;\n\n            this.hasHitZero = false;\n\n            this.displayValue = _max;\n            this.target = _max;\n            this.rebuildImage();\n        }\n\n        get barWidth() {\n            return this._barWidth;\n        }\n\n        set barWidth(v: number) {\n            this._barWidth = v;\n            this.rebuildImage();\n        }\n\n        get barHeight() {\n            return this._barHeight;\n        }\n\n        set barHeight(v: number) {\n            this._barHeight = v;\n            this.rebuildImage();\n        }\n\n        positionNextTo(status: Sprite, target: Sprite) {\n            const padding = this.followPadding;\n            const alignment = this.followOffset;\n            const position = this.explicitlySetDirection != null ?\n                    this.explicitlySetDirection\n                    : (this.isVerticalBar() ? CollisionDirection.Left : CollisionDirection.Top);\n            if (target.flags & sprites.Flag.Destroyed\n                    && !(this.flags & StatusBarFlag.NoAutoDestroy)) {\n                status.destroy();\n            }\n            const toFollowIsRelativeToCamera = !!(target.flags & SpriteFlag.RelativeToCamera);\n            if (!!(status.flags & SpriteFlag.RelativeToCamera) != toFollowIsRelativeToCamera) {\n                status.setFlag(SpriteFlag.RelativeToCamera, toFollowIsRelativeToCamera);\n            }\n\n            if (position === CollisionDirection.Left || position === CollisionDirection.Right) {\n                status.y = target.y + alignment;\n                if (position === CollisionDirection.Right) {\n                    status.left = target.right + padding;\n                } else {\n                    status.right = target.left - padding;\n                }\n            } else {\n                status.x = target.x + alignment;\n                if (position === CollisionDirection.Bottom) {\n                    status.top = target.bottom + padding;\n                } else {\n                    status.bottom = target.top - padding;\n                }\n            }\n        }\n\n        freeze() {\n            this.target = this.displayValue;\n        }\n\n        get label() {\n            return this._label;\n        }\n        \n        set label(v: string) {\n            this._label = v;\n            this.rebuildImage();\n        }\n\n        get max() {\n            return this._max;\n        }\n\n        set max(v: number) {\n            this.changeValue(this.current, v);\n            this.updateState();\n        }\n\n        get current() {\n            return this.target;\n        }\n\n        set current(v: number) {\n            this.changeValue(v, this.max);\n\n            if (!(this.flags & StatusBarFlag.SmoothTransition))\n                this.displayValue = v;\n\n            this.updateState();\n        }\n\n        protected changeValue(current: number, max: number) {\n            const statusHandlers = getStatusHandlers();\n            const toRun = statusHandlers && statusHandlers.filter(h =>\n                h.kind === this.kind\n                    && !(this.flags & StatusBarFlag.IgnoreValueEvents)\n                    && h.conditionMet(current, max)\n                    && !h.conditionMet(this.current, this.max)\n            );\n\n            this.target = current;\n            this._max = max\n\n            if (current <= 0 && !this.hasHitZero && !(this.flags & StatusBarFlag.IgnoreValueEvents)) {\n                this.hasHitZero = true;\n                const handler = (getZeroHandlers() || [])[this.kind];\n                if (this.sprite && handler)\n                    handler(this.sprite);\n            } else if (current > 0 && this.hasHitZero) {\n                // reset if this was below zero and has been refilled\n                this.hasHitZero = false;\n            }\n            \n            for (const h of (toRun || [])) {\n                h.handler(this.sprite);\n            }\n        }\n\n        setFlag(flag: StatusBarFlag, on: boolean) {\n            if (on)\n                this.flags |= flag\n            else\n                this.flags = ~(~this.flags | flag);\n        }\n\n        get image() {\n            return this._image;\n        }\n\n        set image(v: Image) {\n            // ignore, readonly ref outside this class\n        }\n\n        protected isVerticalBar() {\n            return this._barHeight > this._barWidth;\n        }\n\n        protected isSmoothTransition() {\n            return this.flags & StatusBarFlag.SmoothTransition;\n        }\n\n        protected rebuildImage() {\n            let width = this._barWidth;\n            let height = this._barHeight;\n\n            if (this.label) {\n                const labelWidth = this.font.charWidth * this.label.length;\n                if (this.isVerticalBar()) {\n                    width = Math.max(width, labelWidth);\n                    height += this.font.charHeight + 1;\n                } else {\n                    width += labelWidth;\n                    height = Math.max(height, this.font.charHeight);\n                }\n            }\n\n            if (!this.image || width !== this.image.width || height !== this.image.height) {\n                const newImg = image.create(width, height);\n                this._image = newImg;\n            }\n\n            this.updateDisplay();\n        }\n\n        private lastUpdate = game.currentScene().millis();\n        private throttleAmount = 100; \n        updateState() {\n            const { target, displayValue } = this;\n            if (this.flags & StatusBarFlag.ConstrainAssignedValue) {\n                this.target = Math.constrain(target, 0, this.max);\n                this.displayValue = Math.constrain(displayValue, 0, this.max);\n            }\n\n            const currTime = game.currentScene().millis();\n            if (Math.abs(this.lastUpdate - currTime) < this.throttleAmount)\n                return;\n\n            const change = this.max / (Math.max(this._barWidth, this._barHeight) - this.borderWidth * 2);\n\n            if (this.target > this.displayValue) {\n                this.displayValue = Math.min(displayValue + change, this.target);\n                this.lastUpdate = currTime;\n            } else if (this.target < this.displayValue) {\n                this.displayValue = Math.max(displayValue - change, this.target);\n                this.lastUpdate = currTime;\n            }\n            \n            if (displayValue !== this.displayValue) {\n                this.updateDisplay();\n            }\n        }\n\n        updateDisplay() {\n            this.image.fill(0x0);\n            const fillWidth = this._barWidth - 2 * this.borderWidth;\n            const fillHeight = this._barHeight - 2 * this.borderWidth;\n            const barIsVertical = this.isVerticalBar();\n            const borderColor = util.isNullOrUndefined(this.borderColor) ?\n                    this.offColor : this.borderColor;\n    \n            let barLeft = 0;\n            let barTop = 0;\n            \n            if (this.label) {\n                const textWidth = this.font.charWidth * this.label.length;\n                const textHeight = this.font.charHeight;\n                const labelEnd = this.flags & StatusBarFlag.LabelAtEnd;\n\n                let textX = 0;\n                let textY = 0;\n                if (barIsVertical) {\n                    if (labelEnd) {\n                        textY = this._barHeight + 1;\n                    } else {\n                        barTop += textHeight + 1;\n                    }\n                    if (this._barWidth > textWidth) {\n                        textX = (this._barWidth - textWidth) >> 1;\n                    } else if (this._barWidth < textWidth) {\n                        // minus 1 due to 1px padding on right side of fonts\n                        barLeft = (textWidth - this._barWidth - 1) >> 1;\n                    }\n                } else {\n                    if (labelEnd) {\n                        textX = this._barWidth + 1;\n                    } else {\n                        barLeft += textWidth;\n                    }\n                    if (this._barHeight > textHeight) {\n                        textY = (this._barHeight - textHeight) >> 1;\n                    } else if (this._barHeight < textHeight) {\n                        barTop = (textHeight - this._barHeight) >> 1;\n                    }\n                }\n\n                this.image.print(\n                    this.label,\n                    textX,\n                    textY,\n                    this.labelColor,\n                    this.font\n                );\n            }\n\n            this.image.fillRect(\n                barLeft,\n                barTop,\n                this._barWidth,\n                this._barHeight,\n                borderColor\n            );\n\n            this.image.fillRect(\n                barLeft + this.borderWidth,\n                barTop + this.borderWidth,\n                fillWidth,\n                fillHeight,\n                this.offColor\n            );\n\n            if (this.displayValue > 0) {\n                const showTarget = !(this.flags & StatusBarFlag.HideTargetPreview);\n                const invertDir = (this.flags & StatusBarFlag.InvertFillDirection);\n\n                if (showTarget) {\n                    const drainPercent = Math.constrain(\n                        (this.displayValue) / this._max,\n                        0,\n                        1.0\n                    );\n                    const dw = barIsVertical ? fillWidth : Math.round(fillWidth * drainPercent);\n                    const dh = barIsVertical ? Math.round(fillHeight * drainPercent) : fillHeight;\n                    const dx = barLeft + this.borderWidth + ((barIsVertical || !invertDir) ? 0 : fillWidth - dw);\n                    const dy = barTop + this.borderWidth + ((barIsVertical && !invertDir ? fillHeight - dh : 0));\n                    this.image.fillRect(dx, dy, dw, dh, this.drainColor);\n                }\n\n                const percent = Math.constrain(\n                    this.target / this._max,\n                    0,\n                    1.0\n                );\n\n                const tw = barIsVertical ? fillWidth : Math.round(fillWidth * percent);\n                const th = barIsVertical ? Math.round(fillHeight * percent) : fillHeight;\n                const tx = barLeft + this.borderWidth + ((barIsVertical || !invertDir) ? 0 : fillWidth - tw);\n                const ty = barTop + this.borderWidth + ((barIsVertical && !invertDir ? fillHeight - th : 0));\n                this.image.fillRect(tx, ty, tw, th, this.onColor);\n            }\n\n            const handler = (getPostProcessHandlers() || [])[this.kind];\n            if (this.sprite && handler)\n                handler(this.sprite, this.image);\n        }\n    }\n\n    export enum StatusComparison {\n        //% block=\"=\"\n        EQ,\n        //% block=\"≠\"\n        NEQ,\n        //% block=\"<\"\n        LT,\n        //% block=\"≤\"\n        LTE,\n        //% block=\">\"\n        GT,\n        //% block=\"≥\"\n        GTE,\n    }\n\n    export enum ComparisonType {\n        //% block=\"%\"\n        Percentage,\n        //% block=\"fixed\"\n        Fixed\n    }\n\n    class StatusHandler {\n        constructor(\n            public kind: number,\n            protected comparison: StatusComparison,\n            protected comparisonType: ComparisonType,\n            protected percent: number,\n            public handler: (sprite: Sprite) => void\n        ) { }\n\n        conditionMet(current: number, max: number) {\n            const value = this.comparisonType === ComparisonType.Percentage ?\n                (current / max) * 100\n                : current;\n            switch (this.comparison) {\n                // TODO: maybe round / cast to int percent and value for the eq / neq comparison?\n                case StatusComparison.EQ:\n                    return value === this.percent;\n                case StatusComparison.NEQ:\n                    return value !== this.percent;\n                case StatusComparison.GT:\n                    return value > this.percent;\n                case StatusComparison.GTE:\n                    return value >= this.percent;\n                case StatusComparison.LT:\n                    return value < this.percent;\n                case StatusComparison.LTE:\n                    return value <= this.percent;\n                default:\n                    return false;\n            }\n        }\n\n    }\n\n    /**\n     * @param width width of status bar, eg: 20\n     * @param height height of status bar, eg: 4\n     */\n    //% block=\"create status bar sprite width $width height $height kind $kind\"\n    //% block.loc.ru=\"создать спрайт индикатора статуса шириной $width высотой $height типа $kind\"\n    //% kind.shadow=\"statusbars_kind\"\n    //% blockId=\"statusbars_create\"\n    //% blockSetVariable=\"statusbar\"\n    //% help=github:pxt-status-bar/docs/create\n    //% group=\"Create\"\n    //% weight=100\n    export function create(\n        width: number,\n        height: number,\n        kind: number\n    ): StatusBarSprite {\n        let onColor = 0x7;\n        let offColor = 0x2;\n        let drainColor = 0x3;\n\n        if (kind === StatusBarKind.Energy) {\n            onColor = 0x5;\n            offColor = 0xB;\n            drainColor = 0x4;\n        } else if (kind === StatusBarKind.Magic) {\n            onColor = 0x8;\n            offColor = 0xB;\n            drainColor = 0x9;\n        }\n        \n        const sb = new StatusBar(\n            width,\n            height,\n            onColor,\n            offColor,\n            drainColor,\n            100,\n            kind\n        );\n\n        const output = new StatusBarSprite(sb);\n        // below is normally done in `sprites.create`\n        output.setKind(SpriteKind.StatusBar);\n        const cs = game.currentScene();\n        cs.physicsEngine.addSprite(output);\n\n        // run on created handlers\n        cs.createdHandlers\n            .filter(h => h.kind == kind)\n            .forEach(h => h.handler(output));\n\n        sb.sprite = output;\n\n        output.setFlag(SpriteFlag.RelativeToCamera, true);\n        output.setFlag(SpriteFlag.Ghost, true);\n        output.data[STATUS_BAR_DATA_KEY] = sb;\n        output.z = scene.HUD_Z - 5;\n\n        init(output);\n        \n        const handler = (getPostProcessHandlers() || [])[kind];\n        if (output && handler)\n            handler(output, output.image);\n\n        return output;\n    }\n\n    //% block=\"status bar kind $kind attached to $sprite=variables_get(mySprite)\"\n    //% block.loc.ru=\"индикатор статуса типа $kind приклепленный к $sprite=variables_get(mySprite)\"\n    //% blockId=\"statusbars_spriteStatusBarIsAttachedTo\"\n    //% kind.shadow=\"statusbars_kind\"\n    //% help=github:pxt-status-bar/docs/get-status-bar-attached-to\n    //% group=\"Attach\"\n    //% weight=84\n    export function getStatusBarAttachedTo(kind: number, sprite: Sprite) {\n        const managedSprites = getManagedSprites();\n        if (!managedSprites || !sprite)\n            return undefined;\n        return managedSprites.find(s => applyChange(s, sb => sb.spriteToFollow === sprite && sb.kind === kind));\n    }\n\n    //% block=\"on status bar kind $kind zero $status\"\n    //% block.loc.ru=\"когда индикатор статуса типа $kind обнуляется $status\"\n    //% blockId=\"statusbars_onZero\"\n    //% kind.shadow=\"statusbars_kind\"\n    //% draggableParameters=\"reporter\"\n    //% help=github:pxt-status-bar/docs/on-zero\n    //% group=\"Events\"\n    //% weight=60\n    export function onZero(kind: number, handler: (status: StatusBarSprite) => void) {\n        let zeroHandlers = getZeroHandlers();\n        if (!zeroHandlers) {\n            game.currentScene().data[ZERO_HANDLERS_KEY] = zeroHandlers = [];\n        }\n        zeroHandlers[kind] = handler;\n    }\n\n    //% block=\"on status bar kind $kind $comparison $value|$comparisonType $status\"\n    //% block.loc.ru=\"когда индикатор статуса типа $kind $comparison $value|$comparisonType $status\"\n    //% blockId=\"statusbars_onStatusReached\"\n    //% kind.shadow=\"statusbars_kind\"\n    //% draggableParameters=\"reporter\"\n    //% group=\"Events\"\n    //% comparison.defl=statusbars.StatusComparison.LTE\n    //% help=github:pxt-status-bar/docs/on-status-reached\n    //% value.defl=50\n    //% weight=58\n    export function onStatusReached(\n        kind: number,\n        comparison: StatusComparison,\n        comparisonType: ComparisonType,\n        value: number,\n        handler: (status: StatusBarSprite) => void\n    ) {\n        let statusHandlers = getStatusHandlers();\n        if (!statusHandlers) {\n            game.currentScene().data[STATUS_HANDLERS_KEY] = statusHandlers = [];\n        }\n        const statusHandler = new StatusHandler(\n            kind,\n            comparison,\n            comparisonType,\n            value,\n            handler\n        );\n        statusHandlers.push(statusHandler);\n    }\n\n    //% block=\"on status bar kind $kind display updated $status $image\"\n    //% block.loc.ru=\"когда у индикатора статуса типа $kind обновляется отображение $status $image\"\n    //% kind.shadow=\"statusbars_kind\"\n    //% blockId=\"statusbars_postprocessDisplay\"\n    //% draggableParameters=\"reporter\"\n    //% help=github:pxt-status-bar/docs/on-display-updated\n    //% group=\"Events\"\n    //% weight=59\n    export function onDisplayUpdated(kind: number, handler: (status: StatusBarSprite, image: Image) => void) {\n        let displayUpdateHandlers = getPostProcessHandlers();\n        if (!displayUpdateHandlers) {\n            game.currentScene().data[POST_PROCESS_HANDLERS_KEY] = displayUpdateHandlers = [];\n        }\n        displayUpdateHandlers[kind] = handler;\n    }\n\n    //% block=\"array of status bars of $kind\"\n    //% block.loc.ru=\"массив индикаторов статуса типа $kind\"\n    //% kind.shadow=\"statusbars_kind\"\n    //% blockId=\"statusbars_arrayOfKind\"\n    //% blockSetVariable=\"status bar list\"\n    //% help=github:pxt-status-bar/docs/all-of-kind\n    //% group=\"Other\"\n    //% weight=45\n    export function allOfKind(kind: number): StatusBarSprite[] {\n        const managedSprites = getManagedSprites();\n        if (!managedSprites)\n            return [];\n        return managedSprites.filter(status => {\n            const sb = status._statusBar;\n            return sb && sb.kind === kind;\n        });\n    }\n\n    function init(s: StatusBarSprite) {\n        let managedSprites = getManagedSprites();\n        if (!managedSprites) {\n            game.currentScene().data[MANAGED_SPRITES_KEY] = managedSprites = [] as StatusBarSprite[];\n            game.eventContext().registerFrameHandler(scene.UPDATE_PRIORITY + 5, () => {\n                const managed = getManagedSprites();\n                for (let i = managed.length - 1; i >= 0; --i) {\n                    const spr = managed[i];\n                    const sb = spr._statusBar;\n                    if (sb) {\n                        sb.updateState();\n\n                        const { spriteToFollow } = sb;\n                        if (spriteToFollow) {\n                            sb.positionNextTo(spr, spriteToFollow);\n                        }\n                    }\n\n                    if (spr.flags & sprites.Flag.Destroyed) {\n                        // give the garbage collector a helping hand\n                        sb.sprite = undefined;\n                        managed.removeAt(i);\n                        continue;\n                    }\n                }\n            });\n        }\n        \n       managedSprites.push(s);\n    }\n\n    // passes back any return from action for getters / etc\n    function applyChange<T>(status: StatusBarSprite, action: (sb: StatusBar) => T): T {\n        const sb = status._statusBar;\n\n        if (sb) {\n            const output = action(sb);\n            sb.updateDisplay();\n            status.setImage(sb.image);\n            return output;\n        }\n\n        return undefined;\n    }\n\n    function getSceneData(key: string) {\n        return game.currentScene().data[key];\n    }\n\n    function getManagedSprites() {\n        return getSceneData(MANAGED_SPRITES_KEY) as StatusBarSprite[];\n    }\n\n    function getZeroHandlers() {\n        return getSceneData(ZERO_HANDLERS_KEY) as ((status: Sprite) => void)[];\n    }\n\n    function getStatusHandlers() {\n        return getSceneData(STATUS_HANDLERS_KEY) as StatusHandler[];\n    }\n\n    function getPostProcessHandlers() {\n        return getSceneData(POST_PROCESS_HANDLERS_KEY) as ((status: Sprite, image: Image) => void)[];\n    }\n\n    namespace util {\n        export function isNullOrUndefined(v: any): v is null | undefined {\n            return v === undefined || v === null;\n        }\n    }\n}\n","docs/value.md":"# value\n\nGets or sets the current value of the status bar.\n\n## Get\n\n```block\nlet statusbar: StatusBarSprite = null\nlet value = statusbar.value\n```\n\n```typescript-ignore\nlet value = statusbar.value\n```\n\n## Set\n\n```block\nlet statusbar: StatusBarSprite = null\nstatusbar.value = 50\n```\n\n```typescript-ignore\nstatusbar.value = 50\n```\n\n## Property\n\n* **value**: a [number](types/number) to set as the current value for the status bar. The default value is `100`.\n\nBy default, this is constrained between `0` and the **max** value; this can be changed using the `constrain value` flag.\n\n## Example\n\n```blocks\nlet statusbar = statusbars.create(20, 4, StatusBarKind.Health)\nstatusbar.value = 50\nconsole.log(statusbar.value)\n```\n\n```package\npxt-status-bar=github:jwunderl/pxt-status-bar\n```","docs/max.md":"# max\n\nGet or set the current maximum value of the status bar.\n\n## Get\n\n```block\nlet statusbar: StatusBarSprite = null\nlet max = statusbar.max\n```\n\n```typescript-ignore\nlet max = statusbar.max\n```\n\n## Set\n\n```block\nlet statusbar: StatusBarSprite = null\nstatusbar.max = 50\n```\n\n```typescript-ignore\nstatusbar.max = 50\n```\n\n## Property\n\n* **max**: a [number](types/number) that is the maximum value for the status bar.\n\nBy default, the status bar value is kept between `0` and the **max** value. This can be changed using the `constrain value` flag. The default max value is `100`.\n\n## Example\n\n```blocks\nlet statusbar = statusbars.create(20, 4, StatusBarKind.Health)\nstatusbar.max = 50\nconsole.log(statusbar.max)\n```\n\n```package\npxt-status-bar=github:jwunderl/pxt-status-bar\n```","docs/attach-to-sprite.md":"# attach To Sprite\n\nAttach a status bar to a sprite.\n\n```sig\nstatusbars.create(0,0,StatusBarKind.Health).attachToSprite(null)\n```\n\nA status bar is attached to a sprite you specify.\nThe status bar will follow the sprite around the screen instead of being set in a fixed position.\n\nWhen a status bar is attached to a sprite, you can use the `status bar attached to mySprite`\nand `sprite that statusbar is attached to` blocks to get the sprites / status bars that are attached to each other.\n\n## Parameters\n\n* **toFollow**: the sprite to attach to.\n* **padding**: an optional [number](types/number) of pixels to pad around the status bar.\n* **offset**: an optional [number](types/number) of pixels away from the sprite to place the status bar.\n\n## Example\n\n```blocks\nlet statusbar = statusbars.create(20, 4, StatusBarKind.Health)\nlet mySprite = sprites.create(img`\n    . . . . . . . . . . b 5 b . . . \n    . . . . . . . . . b 5 b . . . . \n    . . . . . . b b b b b b . . . . \n    . . . . . b b 5 5 5 5 5 b . . . \n    . . . . b b 5 d 1 f 5 d 4 c . . \n    . . . . b 5 5 1 f f d d 4 4 4 b \n    . . . . b 5 5 d f b 4 4 4 4 b . \n    . . . b d 5 5 5 5 4 4 4 4 b . . \n    . b b d d d 5 5 5 5 5 5 5 b . . \n    b d d d b b b 5 5 5 5 5 5 5 b . \n    c d d b 5 5 d c 5 5 5 5 5 5 b . \n    c b b d 5 d c d 5 5 5 5 5 5 b . \n    c b 5 5 b c d d 5 5 5 5 5 5 b . \n    b b c c c d d d 5 5 5 5 5 d b . \n    . . . . c c d d d 5 5 5 b b . . \n    . . . . . . c c c c c b b . . . \n    `, SpriteKind.Player)\ncontroller.moveSprite(mySprite)\nstatusbar.attachToSprite(mySprite)\n```\n\n```package\npxt-status-bar=github:jwunderl/pxt-status-bar\n```","docs/sprite-attached-to.md":"# sprite Attached To\n\nGet the sprite attached to a given status bar.\n\n```sig\nstatusbars.create(20, 4, StatusBarKind.Health).spriteAttachedTo()\n```\n\n## Returns\n\n* the sprite which the status bar is attached to. If no sprite has been attached, `undefined` is returned.\n\n```blocks\nlet statusbar = statusbars.create(20, 4, StatusBarKind.Health)\nlet mySprite = sprites.create(img`\n    . . . . . . . . . . b 5 b . . . \n    . . . . . . . . . b 5 b . . . . \n    . . . . . . b b b b b b . . . . \n    . . . . . b b 5 5 5 5 5 b . . . \n    . . . . b b 5 d 1 f 5 d 4 c . . \n    . . . . b 5 5 1 f f d d 4 4 4 b \n    . . . . b 5 5 d f b 4 4 4 4 b . \n    . . . b d 5 5 5 5 4 4 4 4 b . . \n    . b b d d d 5 5 5 5 5 5 5 b . . \n    b d d d b b b 5 5 5 5 5 5 5 b . \n    c d d b 5 5 d c 5 5 5 5 5 5 b . \n    c b b d 5 d c d 5 5 5 5 5 5 b . \n    c b 5 5 b c d d 5 5 5 5 5 5 b . \n    b b c c c d d d 5 5 5 5 5 d b . \n    . . . . c c d d d 5 5 5 b b . . \n    . . . . . . c c c c c b b . . . \n    `, SpriteKind.Player)\nstatusbar.attachToSprite(mySprite)\nstatusbar.spriteAttachedTo().say(\":)\")\n```\n\n```package\npxt-status-bar=github:jwunderl/pxt-status-bar\n```","docs/set-color.md":"# set Color\n\nSets the colors for the status bar.\n\n```sig\nstatusbars.create(20, 4, StatusBarKind.Health).setColor(7, 2, 3)\n```\n\n## Parameters\n\n* **fillColor**: a [number](types/number) that is the color that is filled in when a status bar is full.\n* **bkgdColor**: a [number](types/number) that is the color that is shown when a portion is empty (when value is not equal to **max**).\n* **drainColor** a [number](types/number) that is the color that is shown when the bar is emptying out (when `smooth transition` is set to true).\n\nThe colors have different defaults depending on the kind of status bar you are making.\n\n## Examples\n\n```blocks\nlet statusbar = statusbars.create(20, 4, StatusBarKind.Health)\nstatusbar.setColor(7, 2, 3)\n```\n\n```blocks\nlet statusbar = statusbars.create(20, 4, StatusBarKind.Health)\nstatusbar.setColor(7, 2, 3)\nstatusbar.setStatusBarFlag(StatusBarFlag.SmoothTransition, true)\nstatusbar.value = 0\n```\n\n```package\npxt-status-bar=github:jwunderl/pxt-status-bar\n```\n","docs/set-bar-border.md":"# set Bar Border\n\nSet the border for a status bar with the given width and and color.\n\n```sig\nstatusbars.create(20, 4, StatusBarKind.Health).setBarBorder(1, 13)\n```\n\n## Parameters\n\n* **width**: a [number](types/number) which is the width in pixels of the border.\n* **color**: a [number](types/number) that is color, in the current color palette, for the status bar border.\n\n## Example\n\n```blocks\nlet statusbar = statusbars.create(20, 4, StatusBarKind.Health)\nstatusbar.setBarBorder(1, 13)\n```\n\n```package\npxt-status-bar=github:jwunderl/pxt-status-bar\n```","docs/set-label.md":"# set Label\n\nSets the label for a given status bar.\n\n```sig\nstatusbars.create(20, 4, StatusBarKind.Health).setLabel(\"HP\", 10)\n```\n\n## Parameters\n\n* **label**: a [string](types/string) that is the text for the label.\n* **color**: a [number](types/number) that is the display color of the text.\n\nThe label is centered along the status bar.\n\n## Example\n\n```blocks\nlet statusbar = statusbars.create(20, 4, StatusBarKind.Health)\nstatusbar.setLabel(\"HP\", 10)\n```\n\n```package\npxt-status-bar=github:jwunderl/pxt-status-bar\n```","docs/set-status-bar-flag.md":"# set Status Bar Flag\n\nEnable or disable a flag that changes the status bar behavior.\n\n```sig\nstatusbars.create(20, 4, StatusBarKind.Health).setStatusBarFlag(StatusBarFlag.LabelAtEnd, true)\n```\n\n## Parameters\n\n* **flag**: a flag value that modifies the status bar behavior:\n>* `smooth transition`:  When set, update bar over time; otherwise update bar immediately. This is similar to the draining effect that is commonly seen in fighting games.\n>* `label at end`: When set, and label exists, draw label at bottom or right side (instead of top / left side).\n>* `constrain value`: When set, constrain values stored in status bar between 0 and max. This is set to `on` by default.\n>* `invert fill direction`: When set, swap the direction in which a status bar is filled. \n>* `no auto destroy`: When set, this status bar will persist after the sprite it is attached to is destroyed.\n>* `ignore events`: When set, disable `on zero` and `on status changed` events when changing values on this status bar.\n* **on**: a [boolean](types/boolean) that is `true` to set the flag on or `false` to set the flag off.\n\n## Example\n\n```blocks\nlet statusbar = statusbars.create(20, 4, StatusBarKind.Health)\nstatusbar.setStatusBarFlag(StatusBarFlag.LabelAtEnd, true)\nstatusbar.setLabel(\"HP\")\n```\n\n```package\npxt-status-bar=github:jwunderl/pxt-status-bar\n```","docs/set-bar-size.md":"# set Bar Size\n\nSet the width and height of the status bar.\n\n```sig\nstatusbars.create(20, 4, StatusBarKind.Health).setBarSize(5, 20)\n```\n\n## Parameters\n\n* **width**: a [number](types/number) the width in pixels of the status bar.\n* **height**: a [number](types/number) the height in pixels of the status bar.\n\nIf the status bar is set to be taller (height > width),\nthe status bar will fill vertically instead of horizontally.\n\nThe **width** and **height** *include* the border width -- that is,\nif you have a width of 5px and a 1px border,\nthe filled portion of the status bar will have a width of 3px. \n\n## Example\n\n```blocks\nlet statusbar = statusbars.create(20, 4, StatusBarKind.Health)\nstatusbar.setStatusBarFlag(StatusBarFlag.LabelAtEnd, true)\nstatusbar.setBarSize(5, 20)\nstatusbar.value = 50\nstatusbar.setBarBorder(1, 13)\n```\n\n```package\npxt-status-bar=github:jwunderl/pxt-status-bar\n```\n","docs/position-direction.md":"# position Direction\n\nSets the direction in which a status bar is placed.\n\n```sig\nstatusbars.create(20, 4, StatusBarKind.Health).positionDirection(CollisionDirection.Left)\n```\n\nIf the status bar is attached to a sprite, it will be placed on the given side of the sprite.\n\nIf the status bar is not attached to a sprite, it will be placed on the side of the screen the matches the direction chosen.\n\n## Parameters\n\n* **dir**: the direction for the position of the status bar with it's attached sprite.\n\nThe exact positioning can be adjusted using the ``||statusbars:set padding [0] offset [0]||`` block.\n\n## Example\n\n```blocks\nlet statusbar = statusbars.create(20, 4, StatusBarKind.Health)\nstatusbar.positionDirection(CollisionDirection.Left)\nstatusbar.setBarSize(5, 20)\n```\n\n```package\npxt-status-bar=github:jwunderl/pxt-status-bar\n```\n","docs/set-offset-padding.md":"# set Offset Padding\n\nSets the **offset** and **padding** of a status bar from the anchor point of the sprite that it is attached to.\n\n```sig\nstatusbars.create(20, 4, StatusBarKind.Health).setOffsetPadding(0, 5)\n```\n\n## Parameters\n\n* **offset**: a [number](types/number) that says how far along the anchor it should be. For example, if a status bar is placed **above** a sprite,\na positive offset will move it to the **right**, and a negative offset will move it to the **left**.\n* **padding**: a [number](types/number) that says how far away the status bar should be from it's anchor. A negative value puts it closer to the anchor.\n\n```blocks\nlet statusbar = statusbars.create(20, 4, StatusBarKind.Health)\nlet mySprite = sprites.create(img`\n    ...........222222ee.............\n    .........2233333bbeee...........\n    .......2233d1111333bee..........\n    ......23ddd111dd1d33eee.........\n    .....23d1333d1d33d13bee.........\n    ....23d133333d1d33313eee........\n    ...2311333333ddd3333dbeee.......\n    ..2313333333333ddd33d3e44e......\n    ..21d3333333333ddd333db44ee.....\n    .2313333333333dd33333db444ee....\n    .2dd3333333333d333333d3b444e....\n    2311d333333333d333333ddbb444e...\n    2d131d33333333d333333d1b6644e...\n    2d33dd33333333d333333d1b44444e..\n    21333d3333333d3333333d1644664ee.\n    21333d333333d33333333d16b64464be\n    21333dddd33dd33333333d1646446b6e\n    2133333dd11dd33333333d1644b6446e\n    e133333d1d31d33333333d1b4446446e\n    e1333331d3331333333331d6bb44b6e.\n    e1333331dd331b3333333136bb6bb6e.\n    e13333331dd1db33333331b6b66bbe..\n    edd33333311db3333333dd6bb6bbe...\n    e3d3333333d333333333136beebbe...\n    .edd3333333d3333333ddbfeebbe....\n    .e3dd33333dd3333333d3efeeee.....\n    ..e3dd333d1333333dd3bfffff......\n    ...e311111ddd333dddbffeef.......\n    ....eed1d33d111113befeff........\n    ......eeb333dd13beffff..........\n    ........eeeefffffee.............\n    ................................\n    `, SpriteKind.Player)\nstatusbar.attachToSprite(mySprite)\nstatusbar.setOffsetPadding(0, 5)\n```\n\n```package\npxt-status-bar=github:jwunderl/pxt-status-bar\n```\n","docs/create.md":"# Create\n\nCreates a new status bar sprite for use in your games!\n\n```sig\nstatusbars.create(0, 0, StatusBarKind.Health)\n```\n\n### ~hint\n\n#### Status bars are Sprites!\n\nStatus bars are actually sprites; you can use most blocks on them that you can use with other sprites, with a few exceptions:\n\n* Setting their image will not do anything to change the sprite.\n* Status bars have enable / disable a few flags by default; for example, `ghost` and `relative to camera`\n* All status bars have the SpriteKind `StatusBar`\n\n### ~\n\n## Parameters\n\n* **width**: a [number](types/number) that is the width of the status bar.\n* **height**: a [number](types/number) that is the height of the status bar.\n* **kind**: the kind of status bar to create.\n\n## Returns\n\n* a status bar sprite with the width and height chosen, and the kind selected.\n\n## Example\n\n```blocks\nlet statusbar = statusbars.create(20, 4, StatusBarKind.Health)\n```\n\n```package\npxt-status-bar=github:jwunderl/pxt-status-bar\n```\n","docs/get-status-bar-attached-to.md":"# get Status Bar Attached To\n\nGets the status bar of the given kind that is attached to a sprite.\n\n```sig\nstatusbars.getStatusBarAttachedTo(StatusBarKind.Health, null))\n```\n\nThe status bar of the given kind is returned if it is attached to the sprite.\n\n## Parameters\n\n* **kind**: the kind of the status bar to get from the sprite.\n* **sprite**: the sprite to get the status bar from.\n\n## Returns\n\n* the status bar of the requested **kind** is return if it is attached to the **sprite**. Otherwise, `undefined` is returned.\n\n## Example\n\n```blocks\nlet statusbar = statusbars.create(20, 4, StatusBarKind.Health)\nlet mySprite = sprites.create(img`\n    . . . . . . . . . . b 5 b . . . \n    . . . . . . . . . b 5 b . . . . \n    . . . . . . b b b b b b . . . . \n    . . . . . b b 5 5 5 5 5 b . . . \n    . . . . b b 5 d 1 f 5 d 4 c . . \n    . . . . b 5 5 1 f f d d 4 4 4 b \n    . . . . b 5 5 d f b 4 4 4 4 b . \n    . . . b d 5 5 5 5 4 4 4 4 b . . \n    . b b d d d 5 5 5 5 5 5 5 b . . \n    b d d d b b b 5 5 5 5 5 5 5 b . \n    c d d b 5 5 d c 5 5 5 5 5 5 b . \n    c b b d 5 d c d 5 5 5 5 5 5 b . \n    c b 5 5 b c d d 5 5 5 5 5 5 b . \n    b b c c c d d d 5 5 5 5 5 d b . \n    . . . . c c d d d 5 5 5 b b . . \n    . . . . . . c c c c c b b . . . \n    `, SpriteKind.Player)\nstatusbar.attachToSprite(mySprite)\nstatusbars.getStatusBarAttachedTo(StatusBarKind.Health, mySprite).say(\":)\")\n```\n\n```package\npxt-status-bar=github:jwunderl/pxt-status-bar\n```","docs/on-zero.md":"# on Zero\n\nRun code when a status bar of the given kind reaches zero.\n\n```sig\nstatusbars.onZero(StatusBarKind.Health, function (status) {})\n```\n\n## Parameters\n\n* **kind**: the kind of status bar to check it's value for `0`.\n* **status**: the status bar that has a value of `0`.\n\n## Example\n\n```blocks\ncontroller.A.onEvent(ControllerButtonEvent.Pressed, function () {\n    statusbar.value = 0\n})\nstatusbars.onZero(StatusBarKind.Health, function (status) {\n    pause(500)\n    game.over(false)\n})\nlet statusbar: StatusBarSprite = null\nstatusbar = statusbars.create(20, 4, StatusBarKind.Health)\n```\n\n```package\npxt-status-bar=github:jwunderl/pxt-status-bar\n```\n","docs/on-status-reached.md":"# on Status Reached\n\nRun code  when a status bar of the given kind reaches a given threshold.\n\n```sig\nstatusbars.onStatusReached(StatusBarKind.Health, statusbars.StatusComparison.LTE, statusbars.ComparisonType.Percentage, 50, function (status) {\n})\n```\n\nYou can choose whether to set the event to be percentage based (``%``) or fixed points (``fixed``)\n\n## Parameters\n\n* **kind**: the kind of status bar to check status for.\n* **comparison**: the comparison operation to use: <, >, <=, >=, or =.\n* **comparisonType**: the type of comparison, the types are `percentage` or `fixed`.\n* **value**: a [number](types/number) that is the value to compare with.\n\n## Example\n\n```blocks\ncontroller.A.onEvent(ControllerButtonEvent.Pressed, function () {\n    statusbar.value = 25\n})\nstatusbars.onStatusReached(StatusBarKind.Health, statusbars.StatusComparison.LTE, statusbars.ComparisonType.Percentage, 50, function (status) {\n    pause(500)\n    game.over(false)\n})\nlet statusbar: StatusBarSprite = null\nstatusbar = statusbars.create(20, 4, StatusBarKind.Health)\n```\n\n```package\npxt-status-bar=github:jwunderl/pxt-status-bar\n```","docs/on-display-updated.md":"# on Display Updated\n\nRun code when a status bar of the given kind is redrawn.\n\n```sig\nstatusbars.onDisplayUpdated(StatusBarKind.Health, function (0, null) {\n\n})\n```\n\nThis event can be used to modify how a status bar is displayed, like showing an image on top of it.\n\n## Parameters\n\n* **kind**: the kind of status bar.\n* **status**: the status bar with a display update.\n* **image**: the image object for the status bar.\n\n## Example\n\n```blocks\nstatusbars.onDisplayUpdated(StatusBarKind.Health, function (status, image2) {\n    image2.drawRect(0, 0, 4, 4, 11)\n})\nlet statusbar = statusbars.create(20, 4, StatusBarKind.Health)\n```\n\n```package\npxt-status-bar=github:jwunderl/pxt-status-bar\n```\n","docs/all-of-kind.md":"# all Of Kind\n\nGet an array of all status bars of a certain kind.\n\n```sig\nstatusbars.allOfKind(StatusBarKind.Health)\n```\n\n## Parameters\n\n* **kind**: the kind of status bar to return an array for.\n\n## Returns\n\n* an array of status bars of the selected **kind**.\n\n## Example\n\n```blocks\nlet statusbar = statusbars.create(20, 4, StatusBarKind.Health)\nlet status_bar_list = statusbars.allOfKind(StatusBarKind.Health)\n```\n\n```package\npxt-status-bar=github:jwunderl/pxt-status-bar\n```\n","test.ts":"namespace myTiles {\n    //% blockIdentity=images._tile\n    export const tile0 = img`\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n    `\n}\n\nmusic.setVolume(0)\n\nfunction test1() {\n    const status = statusbars.create(50, 3, StatusBarKind.Health)\n    status.setColor(0x7, 0x5)\n    // statusbars.setFlag(status, StatusBarFlag.InvertFillDirection, true);\n    // statusbars.setFlag(status, StatusBarFlag.SmoothTransition, false);\n    // statusbars.setFlag(status, StatusBarFlag.LabelAtEnd, true);\n\n    status.value = 40;\n    status.setLabel(\"HP\", 0x7)\n\n    status.setBarBorder(1, 0xb);\n    status.top = 5;\n    status.left = 5;\n\n    const player = sprites.create(img`\n        . . . . . . f f f f . . . . . .\n        . . . . f f f 2 2 f f f . . . .\n        . . . f f f 2 2 2 2 f f f . . .\n        . . f f f e e e e e e f f f . .\n        . . f f e 2 2 2 2 2 2 e e f . .\n        . . f e 2 f f f f f f 2 e f . .\n        . . f f f f e e e e f f f f . .\n        . f f e f b f 4 4 f b f e f f .\n        . f e e 4 1 f d d f 1 4 e e f .\n        . . f e e d d d d d d e e f . .\n        . . . f e e 4 4 4 4 e e f . . .\n        . . e 4 f 2 2 2 2 2 2 f 4 e . .\n        . . 4 d f 2 2 2 2 2 2 f d 4 . .\n        . . 4 4 f 4 4 5 5 4 4 f 4 4 . .\n        . . . . . f f f f f f . . . . .\n        . . . . . f f . . f f . . . . .\n    `)\n\n    const sb2 = statusbars.create(4, 20, StatusBarKind.Health);\n    sb2.setBarBorder(1, 0xb);\n    sb2.attachToSprite(player, -4, - (image.font5.charHeight / 2))\n    controller.moveSprite(player)\n    sb2.setLabel(\"HP\", 0x7);\n\n    let curr = 40;\n    controller.A.onEvent(ControllerButtonEvent.Pressed, function () {\n        curr -= 5;\n        sb2.value = curr;\n    })\n\n    scene.setBackgroundColor(0x1)\n\n    const sb3 = statusbars.create(5, 30, StatusBarKind.EnemyHealth);\n    sb3.positionDirection(CollisionDirection.Left)\n    sb3.setOffsetPadding(5, 3)\n}\n\nfunction testIcon() {\n    let health: StatusBarSprite = null\n    let enemySb: StatusBarSprite = null\n    tiles.setTilemap(tiles.createTilemap(\n        hex`0a0008000101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101`,\n        img`\n. . . . . . . . . . \n. . . . . . . . . . \n. . . . . . . . . . \n. . . . . . . . . . \n. . . . . . . . . . \n. . . . . . . . . . \n. . . . . . . . . . \n. . . . . . . . . . \n`,\n        [myTiles.tile0,sprites.castle.tileGrass3],\n        TileScale.Sixteen\n    ))\n    let player_character = sprites.create(img`\n    . . . . . . . f f . . . . . . . . . . . \n    . . . . f f f f 2 f f . . . . . . . . . \n    . . f f e e e e f 2 f f . . . . . . . . \n    . f f e e e e e f 2 2 f f . . . . . . . \n    . f e e e e f f e e e e f . . . . . . . \n    . f f f f f e e 2 2 2 2 e f . . . . . . \n    f f f e 2 2 2 f f f f e 2 f . . . . . . \n    f f f f f f f f e e e f f f . . . . . . \n    f e f e 4 4 e b f 4 4 e e f . . . . . . \n    . f e e 4 d 4 b f d d e f . . . . . . . \n    . . f e e e 4 d d d e e . c . . . . . . \n    . . . f 2 2 2 2 e e d d e c c c c c c c \n    . . . f 4 4 4 e 4 4 d d e c d d d d d . \n    . . . f f f f f e e e e . c c c c c . . \n    . . f f f f f f f f . . . c . . . . . . \n    . . f f f . . f f . . . . . . . . . . . \n    `, SpriteKind.Player)\n    player_character.x += -15\n    let enemy = sprites.create(img`\n    . . . . f f f f f . . . . . . \n    . . f f 1 1 1 1 b f f . . . . \n    . f b 1 1 1 1 1 1 1 b f . . . \n    . f 1 1 1 1 1 1 1 1 1 f . . . \n    f d 1 1 1 1 1 1 1 f f f f . . \n    f d 1 1 1 d d 1 c 1 1 1 b f . \n    f b 1 1 f c d f 1 b 1 b f f . \n    f 1 1 1 1 1 b f b f b f f . . \n    f 1 b 1 b d f c f f f f . . . \n    f b f b f c f c c c f . . . . \n    f f f f f f f f f f . . . . . \n    . . . f f f f f f . . . . . . \n    . . . f f f f f f . . . . . . \n    . . . f f f f f f f . . f . . \n    . . . . f f f f f f f f f . . \n    . . . . . f f f f f f f . . . \n    `, SpriteKind.Enemy)\n    enemySb = statusbars.create(20, 4, StatusBarKind.EnemyHealth)\n    enemySb.setBarBorder(1, 12)\n    enemySb.attachToSprite(enemy, 3)\n    enemySb.value = 11\n    health = statusbars.create(5, 40, StatusBarKind.Health)\n    let magic = statusbars.create(40, 5, StatusBarKind.Magic)\n    health.setBarBorder(1, 12)\n    magic.setBarBorder(1, 11)\n    health.x = player_character.left - 7\n    health.y += -3\n    health.value = 75\n    magic.bottom = health.bottom\n    magic.left = health.right + 1\n    magic.value = 30\n\n    statusbars.onZero(StatusBarKind.EnemyHealth, function (status) {\n        status.spriteAttachedTo().destroy()\n    })\n    controller.B.onEvent(ControllerButtonEvent.Pressed, () => {\n        health.value += -10\n    })\n    controller.A.onEvent(ControllerButtonEvent.Pressed, () => {\n        enemySb.value += Math.randomRange(-10, 5)\n    })\n    statusbars.onZero(StatusBarKind.Health, (status) => {\n        game.over(false)\n    })\n}\n\nfunction testRelPosition() {\n    let mySprite2 = sprites.create(img`\n    . . . . . . . . . . . . . . . . \n    . . . . . . . . . . . . . . . . \n    . . . . . . . . . . . . . . . . \n    . . . . . . . . . . . . . . . . \n    . . . . 3 3 . . . . . . . . . . \n    . . . . 3 . 3 3 . . . . . . . . \n    . . . . 3 . . . 3 3 . . . . . . \n    . . . . 3 . . . . 3 . . . . . . \n    . . . . 3 . . . . 3 . . . . . . \n    . . . . 3 . . . . . 3 . . . . . \n    . . . . 3 3 . . . . 3 . . . . . \n    . . . . . 3 3 . . . 3 . . . . . \n    . . . . . . . 3 3 . 3 . . . . . \n    . . . . . . . . . 3 3 . . . . . \n    . . . . . . . . . . . . . . . . \n    . . . . . . . . . . . . . . . . \n    `, SpriteKind.Player)\n    let mySprite = sprites.create(img`\n        . . . . 3 3 3 . . . . . . . . . \n        . . . . 3 . 3 3 . . . . . . . . \n        . . . 3 3 . . 3 3 . . . . . . . \n        . . . 3 . . . . . 3 . . . . . . \n        . . . 3 . . . . . 3 . . . . . . \n        . . . 3 . . . . . . 3 3 . . . . \n        . . 3 . . . . . . . . 3 3 . . . \n        . . 3 . . . . . . . . . 3 3 . . \n        . . 3 . . . . . . . . . . 3 . . \n        . 3 . . . . . . . . . . . . 3 3 \n        . 3 . . . . . . . . . . . . . . \n        . 3 . . . . . . . . . . . . . . \n        . . . . . . . . . . . . . . . . \n        . . . . . . . . . . . . . . . . \n        . . . . . . . . . . . . . . . . \n        . . . . . . . . . . . . . . . . \n        `, SpriteKind.Player)\n    mySprite2.setPosition(16, 15)\n    let statusbar = statusbars.create(20, 4, StatusBarKind.Health)\n    statusbar.attachToSprite(mySprite2)\n    statusbar.setLabel(\"HP\", 1)\n    statusbar.positionDirection(CollisionDirection.Bottom)\n    mySprite.top = statusbar.bottom\n    mySprite.x = statusbar.x\n\n}\n\nfunction testOnUpdated() {\n    statusbars.onDisplayUpdated(StatusBarKind.Health, function (status, image2) {\n        image2.drawRect(0, 0, 3, 3, 11)\n    })\n    let statusbar = statusbars.create(20, 4, StatusBarKind.Health)\n}\n\ntestIcon()\n// test1()\n// testRelPosition()\n// testOnUpdated()"}}